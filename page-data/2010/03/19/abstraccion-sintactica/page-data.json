{"componentChunkName":"component---src-templates-blog-post-js","path":"/2010/03/19/abstraccion-sintactica/","result":{"data":{"site":{"siteMetadata":{"title":"Crazyrobot Blog","author":"Sergio"}},"markdownRemark":{"id":"55d9f28c-3f0b-5182-9078-ee8df168556e","excerpt":"","html":"<p style=\"text-align: center\">\n  </p><div id=\"attachment_194\" style=\"width: 333px\" class=\"wp-caption aligncenter\">\n    <a href=\"http://blog.crazyrobot.net/files/2010/03/joanmiro1.jpg\"><img class=\"size-full wp-image-194 \" src=\"http://blog.crazyrobot.net/files/2010/03/joanmiro1.jpg\" alt=\"le coq\" width=\"323\" height=\"422\"></a>\n    \n    <p class=\"wp-caption-text\">\n      Le Coq - Joan Miro\n    </p>\n  </div>\n  \n  <p>\n    Recordemos algunas nociones básicas.\n  </p>\n  \n  <p>\n    La misión del desarrollador de software consiste en escribir programas que sean faciles de entender. Un programa es facil de entender cuando esta escrito como un conjunto sencillo de relaciones entre conceptos. Como estos conceptos pueden ser a su vez complejos, el programador retiene de ellos unicamente la información necesaria para entender sus relaciones con los demás conceptos. Cada concepto del programa principal es representado por otro pedazo del programa, escrito de manera similar. Este mecanismo de reducción del nivel de detalle de una parte del programa se conoce como <em>abstracción</em>.\n  </p>\n  \n  <p>\n    Si en un programa existen pedazos de código muy similares, el programador debe preguntarse si no existe un concepto implicito que merezca ser representado por una abstracción.\n  </p>\n  \n  <p>\n    Los dos tipos de abstracción mas conocidos son tal vez el <em>procedimiento</em>, que captura una serie de acciones, y los <em>ti</em><em>pos de datos</em>, que representan la entidades sobre las cuales un programa actua. Los diferentes tipos de abstracción permiten reducir la complejidad de los programas de diferentes maneras. Cada lenguaje de programación ofrece sus propios mecanismos de abstracción según el estilo de programación que promueven, por ejemplo funcional u orientado a objetos.\n  </p>\n  \n  <p style=\"text-align: center\">\n    </p><div id=\"attachment_197\" style=\"width: 386px\" class=\"wp-caption aligncenter\">\n      <a href=\"http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing.jpg\"><img class=\"size-full wp-image-197 \" src=\"http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing.jpg\" alt=\"Railway Crossing\" width=\"376\" height=\"310\" srcset=\"http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing-300x247.jpg 300w, http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing-363x300.jpg 363w, http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing.jpg 850w\" sizes=\"(max-width: 376px) 100vw, 376px\"></a>\n      \n      <p class=\"wp-caption-text\">\n        Railway Crossing - Leger\n      </p>\n    </div>\n    \n    <p>\n      La <em>abstracción sintactica</em> permite regrupar formas sintacticas similares. Para explicar a que me refiero con “formas sintacticas similares” daré un ejemplo. En el lenguaje java, en las versiones anteriores a 1.5, la manera mas familiar de iterar sobre un arreglo era escribir algo asi:\n    </p>\n    \n    <p>\n      <code>&lt;br /&gt;\nint[] arreglo = {1,2,3};</code><code> </code>\n    </p>\n    \n    <p>\n      <code>for (int i = 0; i &lt; arreglo.length ; i++){&lt;br /&gt;\nint var = arreglo[i];&lt;br /&gt;\ndoSomethingWith(var);&lt;br /&gt;\n}&lt;br /&gt;\n</code>\n    </p>\n    \n    <p>\n      Al escribir código como este muchas veces, es obvio que hay algo que puede generalizarse. Java 1.5 ofrece la siguiente forma de escribir esto mismo:\n    </p>\n    \n    <p>\n      <code>int[] arreglo = {1,2,3};&lt;br /&gt;\n</code>\n    </p>\n    \n    <p>\n      <code>for (int var : arreglo){&lt;br /&gt;\ndoSomethingWith(var);&lt;br /&gt;\n}</code>\n    </p>\n    \n    <p>\n      La ganancia en legibilidad es enorme cuando se tiene en cuenta el enorme número de iteraciones sobre un arreglo que pueden aparecer en un programa. Como java no ofrece soporte a la abstracción funcional, los programadores de java tuvimos que esperar hasta que los encargados de el lenguaje ofrecieran esta nueva forma de iterar sobre un arreglo, sin poder hacer nada al respecto. En un lenguaje como lisp que permite la abstracción sintactica el programador podría haber creado su propia versión de “for”, de considerarlo necesario. En lisp esto se hace gracias a un poderoso sistema de <em>macros</em>.\n    </p>\n    \n    <p>\n      Veamos otro ejemplo, basado en common lisp pero explicado en pseudo código. Si imaginamos una librería que permita escribir lineas de texto a un archivo, su uso en un lenguaje tradicional se parecerá a esto:\n    </p>\n    \n    <p>\n      <code>&lt;br /&gt;\nvariable stream = open(\"archivo\");&lt;br /&gt;\ntry {&lt;br /&gt;\nprint(stream, \"hello\");&lt;br /&gt;\nprint(stream, \"world\");&lt;br /&gt;\n}&lt;br /&gt;\nfinally {&lt;br /&gt;\nclose(stream);&lt;br /&gt;\n}&lt;br /&gt;\n</code>\n    </p>\n    \n    <p>\n      Luego de escribir código parecido al anterior muchas veces, podemos imaginar lo conveniente que sería reducir lo anterior a una forma mas pura, algo parecido a esto:\n    </p>\n    \n    <p>\n      <code>&lt;br /&gt;\nwith-open-file (stream \"archivo\") {&lt;br /&gt;\nstream.print(\"hello world\");&lt;br /&gt;\n}</code>\n    </p>\n    \n    <p>\n      que “esconda” los detalles de captura de excepciones y de cerrar el <em>stream</em> al final de su uso.\n    </p>\n    \n    <p>\n      En lisp existe un macro que hace exactamente eso. Pero el punto aquí no es que lisp soporte esta sintaxis sino que, de no existir, el programador podria introducirla sin ningun problema.\n    </p>","frontmatter":{"title":"Abstracción sintactica","date":"March 19, 2010","description":"none"}}},"pageContext":{"slug":"/2010/03/19/abstraccion-sintactica/","previous":{"fields":{"slug":"/2010/03/12/programacion-interactiva/"},"frontmatter":{"title":"Programación interactiva"}},"next":{"fields":{"slug":"/2010/03/26/twitter-as-simple-as-possible-but-not-simpler/"},"frontmatter":{"title":"Twitter: “as simple as possible, but not simpler”"}}}},"staticQueryHashes":["63159454","734670849"]}