{"componentChunkName":"component---src-templates-blog-post-js","path":"/2010/03/19/abstraccion-sintactica/","webpackCompilationHash":"4345c0b03c37f34c9fd3","result":{"data":{"site":{"siteMetadata":{"title":"Crazyrobot Blog","author":"Sergio"}},"markdownRemark":{"id":"3b818d06-3e17-5813-8b87-7303794317b9","excerpt":"","html":"<p style=\"text-align: center\">\n  </p><div id=\"attachment_194\" style=\"width: 333px\" class=\"wp-caption aligncenter\">\n    <a href=\"http://blog.crazyrobot.net/files/2010/03/joanmiro1.jpg\"><img class=\"size-full wp-image-194 \" src=\"http://blog.crazyrobot.net/files/2010/03/joanmiro1.jpg\" alt=\"le coq\" width=\"323\" height=\"422\"></a>\n    \n    <p class=\"wp-caption-text\">\n      Le Coq - Joan Miro\n    </p>\n  </div>\n  \n  <p>\n    Recordemos algunas nociones b&#xE1;sicas.\n  </p>\n  \n  <p>\n    La misi&#xF3;n del desarrollador de software consiste en escribir programas que sean faciles de entender. Un programa es facil de entender cuando esta escrito como un conjunto sencillo de relaciones entre conceptos. Como estos conceptos pueden ser a su vez complejos, el programador retiene de ellos unicamente la informaci&#xF3;n necesaria para entender sus relaciones con los dem&#xE1;s conceptos. Cada concepto del programa principal es representado por otro pedazo del programa, escrito de manera similar. Este mecanismo de reducci&#xF3;n del nivel de detalle de una parte del programa se conoce como <em>abstracci&#xF3;n</em>.\n  </p>\n  \n  <p>\n    Si en un programa existen pedazos de c&#xF3;digo muy similares, el programador debe preguntarse si no existe un concepto implicito que merezca ser representado por una abstracci&#xF3;n.\n  </p>\n  \n  <p>\n    Los dos tipos de abstracci&#xF3;n mas conocidos son tal vez el <em>procedimiento</em>, que captura una serie de acciones, y los <em>ti</em><em>pos de datos</em>, que representan la entidades sobre las cuales un programa actua. Los diferentes tipos de abstracci&#xF3;n permiten reducir la complejidad de los programas de diferentes maneras. Cada lenguaje de programaci&#xF3;n ofrece sus propios mecanismos de abstracci&#xF3;n seg&#xFA;n el estilo de programaci&#xF3;n que promueven, por ejemplo funcional u orientado a objetos.\n  </p>\n  \n  <p style=\"text-align: center\">\n    </p><div id=\"attachment_197\" style=\"width: 386px\" class=\"wp-caption aligncenter\">\n      <a href=\"http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing.jpg\"><img class=\"size-full wp-image-197 \" src=\"http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing.jpg\" alt=\"Railway Crossing\" width=\"376\" height=\"310\" srcset=\"http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing-300x247.jpg 300w, http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing-363x300.jpg 363w, http://blog.crazyrobot.net/files/2010/03/Leger_railway_crossing.jpg 850w\" sizes=\"(max-width: 376px) 100vw, 376px\"></a>\n      \n      <p class=\"wp-caption-text\">\n        Railway Crossing - Leger\n      </p>\n    </div>\n    \n    <p>\n      La <em>abstracci&#xF3;n sintactica</em> permite regrupar formas sintacticas similares. Para explicar a que me refiero con &#x201C;formas sintacticas similares&#x201D; dar&#xE9; un ejemplo. En el lenguaje java, en las versiones anteriores a 1.5, la manera mas familiar de iterar sobre un arreglo era escribir algo asi:\n    </p>\n    \n    <p>\n      <code>&lt;br /&gt;\nint[] arreglo = {1,2,3};</code><code> </code>\n    </p>\n    \n    <p>\n      <code>for (int i = 0; i &lt; arreglo.length ; i++){&lt;br /&gt;\nint var = arreglo[i];&lt;br /&gt;\ndoSomethingWith(var);&lt;br /&gt;\n}&lt;br /&gt;\n</code>\n    </p>\n    \n    <p>\n      Al escribir c&#xF3;digo como este muchas veces, es obvio que hay algo que puede generalizarse. Java 1.5 ofrece la siguiente forma de escribir esto mismo:\n    </p>\n    \n    <p>\n      <code>int[] arreglo = {1,2,3};&lt;br /&gt;\n</code>\n    </p>\n    \n    <p>\n      <code>for (int var : arreglo){&lt;br /&gt;\ndoSomethingWith(var);&lt;br /&gt;\n}</code>\n    </p>\n    \n    <p>\n      La ganancia en legibilidad es enorme cuando se tiene en cuenta el enorme n&#xFA;mero de iteraciones sobre un arreglo que pueden aparecer en un programa. Como java no ofrece soporte a la abstracci&#xF3;n funcional, los programadores de java tuvimos que esperar hasta que los encargados de el lenguaje ofrecieran esta nueva forma de iterar sobre un arreglo, sin poder hacer nada al respecto. En un lenguaje como lisp que permite la abstracci&#xF3;n sintactica el programador podr&#xED;a haber creado su propia versi&#xF3;n de &#x201C;for&#x201D;, de considerarlo necesario. En lisp esto se hace gracias a un poderoso sistema de <em>macros</em>.\n    </p>\n    \n    <p>\n      Veamos otro ejemplo, basado en common lisp pero explicado en pseudo c&#xF3;digo. Si imaginamos una librer&#xED;a que permita escribir lineas de texto a un archivo, su uso en un lenguaje tradicional se parecer&#xE1; a esto:\n    </p>\n    \n    <p>\n      <code>&lt;br /&gt;\nvariable stream = open(&quot;archivo&quot;);&lt;br /&gt;\ntry {&lt;br /&gt;\nprint(stream, &quot;hello&quot;);&lt;br /&gt;\nprint(stream, &quot;world&quot;);&lt;br /&gt;\n}&lt;br /&gt;\nfinally {&lt;br /&gt;\nclose(stream);&lt;br /&gt;\n}&lt;br /&gt;\n</code>\n    </p>\n    \n    <p>\n      Luego de escribir c&#xF3;digo parecido al anterior muchas veces, podemos imaginar lo conveniente que ser&#xED;a reducir lo anterior a una forma mas pura, algo parecido a esto:\n    </p>\n    \n    <p>\n      <code>&lt;br /&gt;\nwith-open-file (stream &quot;archivo&quot;) {&lt;br /&gt;\nstream.print(&quot;hello world&quot;);&lt;br /&gt;\n}</code>\n    </p>\n    \n    <p>\n      que &#x201C;esconda&#x201D; los detalles de captura de excepciones y de cerrar el <em>stream</em> al final de su uso.\n    </p>\n    \n    <p>\n      En lisp existe un macro que hace exactamente eso. Pero el punto aqu&#xED; no es que lisp soporte esta sintaxis sino que, de no existir, el programador podria introducirla sin ningun problema.\n    </p>","frontmatter":{"title":"Abstracción sintactica","date":"March 19, 2010","description":"none"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2010/03/19/abstraccion-sintactica/","previous":{"fields":{"slug":"/2010/03/12/programacion-interactiva/"},"frontmatter":{"title":"Programación interactiva"}},"next":{"fields":{"slug":"/2010/03/26/twitter-as-simple-as-possible-but-not-simpler/"},"frontmatter":{"title":"Twitter: “as simple as possible, but not simpler”"}}}}}